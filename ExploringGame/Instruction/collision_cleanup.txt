# GOAL
Cleanup collision handling for easier integration with new object types 

# CURRENT IMPLEMENTATION
- we have a CollisionGroup that defines what kind of object it is
- but then we are hard-coding the collision relationships, which makes it hard to add new object types

# PROPOSAL
1. collidable objects need two CollisionGroups
	- CollisionGroup - what group THIS object is
	- CollidesWithGroups - what groups this object can collide with
2. We use the "tag" property currently to store CollisionGroup, change instead to store a CollisionInfo record which has those properties
3. Simplify CollisionGroupFilter to use these properties instead of hard-coded logic

# QUESTIONS AND ANSWERS
Q. CollidesWithGroups - Should this be: A single CollisionGroup using flags (recommended) pr a List<CollisionGroup> or HashSet<CollisionGroup>?
	- use Flags

# IMPLEMENTATION - ? COMPLETE

## Changes Made:

### 1. CollisionGroup Enum (Physics.cs)
- Added `[Flags]` attribute
- Added `None = 0` and `All` values
- Enum values already used powers of 2: Player=1, Environment=2, Doors=4, Steps=8, SolidEntity=16

### 2. CollisionInfo Record (Physics.cs)
```csharp
public record CollisionInfo(CollisionGroup MyGroup, CollisionGroup CollidesWithGroups);
```

### 3. Updated All RigidBody.Tag Assignments
All methods in Physics.cs now use CollisionInfo:
- `CreateMeshShape` - Environment collides with Player | SolidEntity
- `CreateStaticSurface` - Environment collides with Player | SolidEntity
- `CreateStaticBody` - Dynamic based on group (Steps only with Player, others with Player | SolidEntity)
- `CreateDynamicBody` - Environment collides with Player | SolidEntity
- `CreateCapsule` - Overloaded to support custom groups, defaults to Player
- `CreateHingedDoor` - Doors collide with Player

### 4. Simplified CollisionGroupFilter
Replaced hard-coded if/else chain with bitwise flag checking:
```csharp
bool aCollidesWithB = (infoA.CollidesWithGroups & infoB.MyGroup) != 0;
bool bCollidesWithA = (infoB.CollidesWithGroups & infoA.MyGroup) != 0;
```
- Kept special case for FlyMode (Player + Environment)
- Collision is bidirectional - both objects must allow it

### 5. Updated CollisionModifier
Changed from casting to CollisionGroup to using CollisionInfo:
```csharp
var infoA = shapeA.RigidBody.Tag as CollisionInfo;
if (infoA?.MyGroup == CollisionGroup.Steps)
```

### 6. Enhanced EntityMover
Added constructor parameters for custom collision groups:
```csharp
public EntityMover(IWithPosition entity, Physics physics, 
    CollisionGroup myGroup = CollisionGroup.Player, 
    CollisionGroup collidesWithGroups = ...)
```

### 7. Updated TestEntityController
TestEntity now uses SolidEntity collision group:
```csharp
_entityMover = new EntityMover(Shape, _physics, 
    CollisionGroup.SolidEntity, 
    CollisionGroup.Environment | CollisionGroup.Player);
```

## Benefits:

? **Extensible**: Adding new entity types no longer requires modifying collision filter logic
? **Declarative**: Collision relationships are declared at object creation time
? **Maintainable**: Collision logic is centralized in one simple bitwise check
? **Flexible**: Each object can specify exactly what it collides with using flags
? **Type-safe**: CollisionInfo is a record with clear semantics

## How to Add New Entity Types:

1. Define collision groups in CollisionInfo when creating the body:
```csharp
body.Tag = new CollisionInfo(
    MyGroup: CollisionGroup.NewType,
    CollidesWithGroups: CollisionGroup.Player | CollisionGroup.Environment
);
```

2. No changes needed to CollisionGroupFilter!

## Testing:
- Build successful
- TestEntity demonstrates SolidEntity usage
- All existing collision relationships preserved